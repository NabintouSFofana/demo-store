{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useMemo } from 'react';\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { HYDRATE } from 'next-redux-wrapper';\nimport thunk from 'redux-thunk';\nimport { STORE_PRODUCTS, STORE_CATEGORIES, RETRIEVE_CART_SUCCESS, ADD_TO_CART_SUCCESS, UPDATE_CART_ITEM_SUCCESS, REMOVE_FROM_CART_SUCCESS, CAPTURE_ORDER_SUCCESS, GENERATE_CHECKOUT_TOKEN, GET_SHIPPING_OPTIONS, REMOVE_SHIPPING_OPTIONS, UPDATE_CHECKOUT_LIVE_OBJECT, ABORT_CHECKOUT, SET_CUSTOMER, CLEAR_CUSTOMER } from './actions/actionTypes';\nlet store; // Declare initial state\n\nconst initialState = {\n  categories: [],\n  products: [],\n  cart: {},\n  checkout: {\n    shippingOptions: [],\n    checkoutTokenObject: {}\n  },\n  orderReceipt: null,\n  customer: null\n}; // Create reducer\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case HYDRATE:\n      // These are server side rendered from MyApp.getInitialProps, everything else should\n      // come from client side state and should not be overwritten here by subsequent server\n      // side hydration actions.\n      const {\n        categories,\n        products\n      } = action.payload;\n      return _objectSpread(_objectSpread({}, state), {}, {\n        categories,\n        products\n      });\n    // Dispatch in App SSR\n    // Check if action dispatched is STORE_CATEGORIES and act on that\n\n    case STORE_CATEGORIES:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        categories: action.payload\n      });\n    // Dispatch in App SSR\n    // Check if action dispatched is STORE_PRODUCTS and act on that\n\n    case STORE_PRODUCTS:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        products: action.payload\n      });\n    // Dispatch in App client-side\n    // Check if action dispatched is SET_CUSTOMER and act on that\n\n    case CLEAR_CUSTOMER:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        customer: null\n      });\n\n    case SET_CUSTOMER:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        customer: action.payload\n      });\n    // Dispatch in Product client-side\n    // Check if action dispatched is STORE_CART and act on that\n\n    case RETRIEVE_CART_SUCCESS:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        cart: action.payload\n      });\n    // Dispatch in ProductDetail client-side\n    // Check if action dispatched is ADD_TO_CART and act on that\n\n    case ADD_TO_CART_SUCCESS:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        cart: action.payload.cart\n      });\n    // Dispatch in Cart client-side\n    // Check if action dispatched is UPDATE_CART_ITEM and act on that\n\n    case UPDATE_CART_ITEM_SUCCESS:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        cart: action.payload.cart\n      });\n    // Dispatch in Cart client-side\n    // Check if action dispatched is REMOVE_FROM_CART and act on that\n\n    case REMOVE_FROM_CART_SUCCESS:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        cart: action.payload.cart\n      });\n    // Dispatch in Checkout client-side\n\n    case GENERATE_CHECKOUT_TOKEN:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        checkout: _objectSpread(_objectSpread({}, state.checkout), {}, {\n          checkoutTokenObject: action.payload\n        })\n      });\n    // Dispatch in Checkout client-side\n\n    case GET_SHIPPING_OPTIONS:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        checkout: _objectSpread(_objectSpread({}, state.checkout), {}, {\n          shippingOptions: action.payload\n        })\n      });\n    // Dispatch in Checkout client-side\n\n    case REMOVE_SHIPPING_OPTIONS:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        checkout: _objectSpread(_objectSpread({}, state.checkout), {}, {\n          shippingOptions: []\n        })\n      });\n    // Dispatch in Checkout client-side\n\n    case UPDATE_CHECKOUT_LIVE_OBJECT:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        checkout: _objectSpread(_objectSpread({}, state.checkout), {}, {\n          checkoutTokenObject: _objectSpread(_objectSpread({}, state.checkout.checkoutTokenObject), {}, {\n            live: action.payload\n          })\n        })\n      });\n    // Dispatch in Checkout client-side\n\n    case ABORT_CHECKOUT:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        checkout: initialState.checkout\n      });\n    // Dispatch in Checkout client-side\n\n    case CAPTURE_ORDER_SUCCESS:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        checkout: initialState.checkout,\n        orderReceipt: action.payload\n      });\n\n    default:\n      return state;\n  }\n}; // Enable Redux dev tools\n\n\nconst devtools = false && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__({\n  trace: true,\n  traceLimit: 25\n}) : f => f; // Create a makeStore function and pass in reducer to create the store\n\nconst makeStore = () => {\n  return createStore(reducer, initialState, compose(applyMiddleware(thunk), devtools));\n};\n\nexport const initializeStore = initialState => {\n  var _store2;\n\n  let _store = (_store2 = store) !== null && _store2 !== void 0 ? _store2 : makeStore(initialState); // After navigating to a page with an initial Redux state, merge that state\n  // with the current state in the store, and create a new store\n\n\n  if (initialState && store) {\n    _store = makeStore(_objectSpread(_objectSpread({}, store.getState()), initialState)); // Reset the current store\n\n    store = undefined;\n  } // For SSG and SSR always create a new store\n\n\n  if (true) {\n    return _store;\n  } // Create the store once in the client\n\n\n  if (!store) {\n    store = _store;\n  }\n\n  return _store;\n};\nexport function useStore(initialState) {\n  const store = useMemo(() => initializeStore(initialState), [initialState]);\n  return store;\n}","map":{"version":3,"sources":["C:/Users/sandi/chec-store/store/index.js"],"names":["useMemo","createStore","applyMiddleware","compose","HYDRATE","thunk","STORE_PRODUCTS","STORE_CATEGORIES","RETRIEVE_CART_SUCCESS","ADD_TO_CART_SUCCESS","UPDATE_CART_ITEM_SUCCESS","REMOVE_FROM_CART_SUCCESS","CAPTURE_ORDER_SUCCESS","GENERATE_CHECKOUT_TOKEN","GET_SHIPPING_OPTIONS","REMOVE_SHIPPING_OPTIONS","UPDATE_CHECKOUT_LIVE_OBJECT","ABORT_CHECKOUT","SET_CUSTOMER","CLEAR_CUSTOMER","store","initialState","categories","products","cart","checkout","shippingOptions","checkoutTokenObject","orderReceipt","customer","reducer","state","action","type","payload","live","devtools","window","__REDUX_DEVTOOLS_EXTENSION__","trace","traceLimit","f","makeStore","initializeStore","_store","getState","undefined","useStore"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\r\nimport { createStore, applyMiddleware, compose } from 'redux';\r\nimport { HYDRATE } from 'next-redux-wrapper';\r\nimport thunk from 'redux-thunk';\r\n\r\nimport {\r\n  STORE_PRODUCTS,\r\n  STORE_CATEGORIES,\r\n  RETRIEVE_CART_SUCCESS,\r\n  ADD_TO_CART_SUCCESS,\r\n  UPDATE_CART_ITEM_SUCCESS,\r\n  REMOVE_FROM_CART_SUCCESS,\r\n  CAPTURE_ORDER_SUCCESS,\r\n  GENERATE_CHECKOUT_TOKEN,\r\n  GET_SHIPPING_OPTIONS,\r\n  REMOVE_SHIPPING_OPTIONS,\r\n  UPDATE_CHECKOUT_LIVE_OBJECT,\r\n  ABORT_CHECKOUT,\r\n  SET_CUSTOMER,\r\n  CLEAR_CUSTOMER,\r\n} from './actions/actionTypes';\r\n\r\nlet store\r\n// Declare initial state\r\nconst initialState = {\r\n  categories: [],\r\n  products: [],\r\n  cart: {},\r\n  checkout: {\r\n    shippingOptions: [],\r\n    checkoutTokenObject: {},\r\n  },\r\n  orderReceipt: null,\r\n  customer: null,\r\n};\r\n\r\n// Create reducer\r\nconst reducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case HYDRATE:\r\n      // These are server side rendered from MyApp.getInitialProps, everything else should\r\n      // come from client side state and should not be overwritten here by subsequent server\r\n      // side hydration actions.\r\n      const { categories, products } = action.payload;\r\n\r\n      return {\r\n        ...state,\r\n        categories,\r\n        products,\r\n      };\r\n    // Dispatch in App SSR\r\n    // Check if action dispatched is STORE_CATEGORIES and act on that\r\n    case STORE_CATEGORIES:\r\n      return { ...state, categories: action.payload };\r\n    // Dispatch in App SSR\r\n    // Check if action dispatched is STORE_PRODUCTS and act on that\r\n    case STORE_PRODUCTS:\r\n      return { ...state, products: action.payload };\r\n    // Dispatch in App client-side\r\n    // Check if action dispatched is SET_CUSTOMER and act on that\r\n    case CLEAR_CUSTOMER:\r\n      return { ...state, customer: null };\r\n    case SET_CUSTOMER:\r\n      return { ...state, customer: action.payload };\r\n    // Dispatch in Product client-side\r\n    // Check if action dispatched is STORE_CART and act on that\r\n    case RETRIEVE_CART_SUCCESS:\r\n      return { ...state, cart: action.payload };\r\n    // Dispatch in ProductDetail client-side\r\n    // Check if action dispatched is ADD_TO_CART and act on that\r\n    case ADD_TO_CART_SUCCESS:\r\n      return { ...state, cart: action.payload.cart };\r\n    // Dispatch in Cart client-side\r\n    // Check if action dispatched is UPDATE_CART_ITEM and act on that\r\n    case UPDATE_CART_ITEM_SUCCESS:\r\n      return { ...state, cart: action.payload.cart };\r\n    // Dispatch in Cart client-side\r\n    // Check if action dispatched is REMOVE_FROM_CART and act on that\r\n    case REMOVE_FROM_CART_SUCCESS:\r\n      return { ...state, cart: action.payload.cart };\r\n    // Dispatch in Checkout client-side\r\n    case GENERATE_CHECKOUT_TOKEN:\r\n      return { ...state, checkout: { ...state.checkout, checkoutTokenObject: action.payload }};\r\n    // Dispatch in Checkout client-side\r\n    case GET_SHIPPING_OPTIONS:\r\n      return { ...state, checkout: { ...state.checkout, shippingOptions: action.payload }};\r\n    // Dispatch in Checkout client-side\r\n    case REMOVE_SHIPPING_OPTIONS:\r\n      return { ...state, checkout: { ...state.checkout, shippingOptions: [] }};\r\n    // Dispatch in Checkout client-side\r\n    case UPDATE_CHECKOUT_LIVE_OBJECT:\r\n      return {\r\n        ...state,\r\n        checkout: {\r\n          ...state.checkout,\r\n          checkoutTokenObject: {\r\n            ...state.checkout.checkoutTokenObject,\r\n            live: action.payload\r\n          },\r\n        },\r\n      };\r\n    // Dispatch in Checkout client-side\r\n    case ABORT_CHECKOUT:\r\n      return { ...state, checkout: initialState.checkout };\r\n    // Dispatch in Checkout client-side\r\n    case CAPTURE_ORDER_SUCCESS:\r\n      return { ...state, checkout: initialState.checkout, orderReceipt: action.payload };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\n\r\n\r\n// Enable Redux dev tools\r\nconst devtools = (process.browser && window.__REDUX_DEVTOOLS_EXTENSION__)\r\n  ? window.__REDUX_DEVTOOLS_EXTENSION__(\r\n    { trace: true, traceLimit: 25 }\r\n  )\r\n  : f => f;\r\n\r\n// Create a makeStore function and pass in reducer to create the store\r\nconst makeStore = () => {\r\n  return createStore(\r\n    reducer,\r\n    initialState,\r\n    compose(applyMiddleware(thunk), devtools)\r\n  );\r\n};\r\n\r\n\r\nexport const initializeStore = (initialState) => {\r\n  let _store = store ?? makeStore(initialState)\r\n\r\n  // After navigating to a page with an initial Redux state, merge that state\r\n  // with the current state in the store, and create a new store\r\n  if (initialState && store) {\r\n    _store = makeStore({\r\n      ...store.getState(),\r\n      ...initialState,\r\n    })\r\n    // Reset the current store\r\n    store = undefined\r\n  }\r\n\r\n  // For SSG and SSR always create a new store\r\n  if (typeof window === 'undefined') {\r\n    return _store\r\n  }\r\n  // Create the store once in the client\r\n  if (!store) {\r\n    store = _store\r\n  }\r\n\r\n  return _store\r\n}\r\n\r\n\r\nexport function useStore(initialState) {\r\n  const store = useMemo(() => initializeStore(initialState), [initialState])\r\n  return store\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}